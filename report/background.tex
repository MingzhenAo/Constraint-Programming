\chapter{Background}
\label{cha:background}
\section{Constraint Satisfaction Problem}
A constraint satisfaction problem (CSP) consists of \cite{r18}:
\begin{itemize}
  \item a set of variables $V = \{{v_{1}, v_{2},..., v_{n}}\}$,
  \item a set of domains $D = \{D_{1}, D_{2},..., D_{n}\}$ such that for each
variable $v_{i} \in V$ there is a domain $D_{i}$ which is a finite set of objects that can be assigned to $v_{i}$,
  \item a set of constraints $C = \{C_{1}, C_{2},..., C_{k}\}$ such that the scope of each constraint is a subset of $V$. A constraint can be represented as a pair ($V_{s}$,$A_{s}$), where $V_{s}$ is a set of variables which is called scope and $A_{s}$ is a set of complete assignments for $V_{s}$.
\end{itemize}
"A solution to a CSP is a complete instantiation of the variables in $V$ satisfying all the constraints in $C$" \cite{r18}. Such a problem is usually solved by a form of search. However, it is an NP-complete problem which means that there does not exist an algorithm to solve it in polynomial time at the moment. Only if P=NP, there is such an algorithm. Therefore, solving a CSP in a reasonable time requires the combination of optimization methods. In our case, even though different solvers adopt various optimization methods (more details in Chapter 4), arc consistency is commonly used by CSP solvers.\\ 
"A variable $v$ is arc consistent with respect to another variable $u$ if and only if for every $d \in D_{v}$ there is at least one $d'\in D_{u}$ such that $(d,d')\in C_{v,u}$" \cite{r7}. Accordingly, a CSP is arc consistent if and only if all pairs of variables are arc consistent with each other. Based on arc consistency, the values that break arc consistency in the domains will be removed, which significantly decreases the number of search nodes so that it saves a lot of search time. Therefore, it takes up a vital position in the optimizations of CSP. Furthermore, the most famous algorithm that achieve arc consistency for CSP is AC3 which is proposed for binary constraint networks. The time complexity of AC3 is in $O(ek^{3})$ and space complexity is in $O(e)$, where $e$ means the number of constraints and $k$ means the maximum domain size \cite{r11}.
\section{Rotation Matrix}
"Rotation is the action of moving or causing to move in a circle round an axis or centre" and "Vector is a quantity having direction as well as magnitude, especially as determining the position of one point in space relative to another" \cite{r14}. After the rotation of a vector, the magnitude which is the length of the vector will be preserved, only the direction of the vector will be changed. The process can be represented by a matrix operation such as 
\begin{equation}
Y=M.X,
\end{equation}
where $X$ is the input vector, $M$ is the rotation matrix and $Y$ is the output vector \cite{r15}. Therefore, the rotation matrices can be used to mathematically define rotations that can describe the placements for the pieces of the two games. The 2D rotation matrix will be used to model IQ twist and the 3D rotation matrix will be used to model ZIG ZAG Puzzler. In our case, only counter-clockwise rotations of 90, 180 and 270 degrees for both 2D (the xy-plane) and 3D (the xy-plane, the yz-plane and the xz-plane) will be considered.
\section{Minizinc Language}
Minizinc \cite{r10} is a simple and readily comprehensible constraint programming (CP) modelling language that aims to become the first standard modelling language for CP problems. The designers hope that Minizinc can be adopted by different solvers so that a modeller can compare different solvers for a problem. It usually appears together with the Minizinc-to-Flatzinc translator which transforms the Minizinc language into the Flatzinc language. Flatzinc \cite{r10} is a low-level solver-input language. Compared with Minizinc that is a high-level language, it is easier to be adapted by an interface, more effective and storage-saving but hard to understand for programmers. If a solver writer wants to support the Minizinc language, he or she just needs to write a simple Flatzinc frond-end to their solver. As is shown in Figure 2.1, it plays the role of a bridge that connects the Minizinc file with respective interfaces for different solvers. 
\begin{figure}[htbp]
\centering
\includegraphics[width=0.8\linewidth]{figs/flowofMinizinc.png}
\caption{The process of a solver executing a Minizinc file}
  \label{fig:process}
\end{figure}
A Minizinc problem consists of two parts: the structure of the problem is corresponding to the model and the assignments to parameters for a particular problem are corresponding to the data. In addition, what it mainly supports has been listed below \cite{r10}:\\
\begin{compactenum}
  \item Scalar types: Booleans, integers and floats.
  \item Compound types: sets and arrays.
  \item Built-in operations: 
  \begin{compactitem}
  \item comparisons (e.g. <, ==),
  \item arithmetic operations (e.g. +, *, sum, min, mod, div),
  \item logical operations (e.g. $\vee$, $\wedge$, xor, forall),
  \item set operations (e.g. union, subset, in, card),
  \item array operations (e.g. length, index\_set),
  \item coercions (e.g. round, int2float, bool2int), 
  \item bounds operations (ub, lb, dom).
  \end{compactitem}
  \item Predicates: users can define their own predicates.
  \item Functions: users can define their own functions.
  \item Global Constraints: 'globals.mzn' which includes all global constraints.
\end{compactenum}
In my case, the "$\vee$", "$\wedge$", "mod", "div", "alldifferent.mzn" from "globals.mzn", "set of int" and some functions have been used.\\
For Figure~\ref{fig:minizincexample1}, the contents in line 1 are notes, which usually start from "\%". They provide more explanations for reader to understand the codes. The contents in line 2 aim to call "alldifferent.mzn", which contains "alldifferent" constraint. The "alldifferent.mzn" can be replaced by "globals.mzn" that contains all global constraints. Accordingly, in Figure~\ref{fig:minizincexample2}, line 34 call the constraint. From line 3 to line 4, the functions are defined by the user. From line 5 to 18, all variables and corresponding types has been defined. As an example, "var position: Vb11;" means Vb11 is a variable, and the type of Vb11 is position. Therefore, the domain of Vb11 is the elements in position. In addition, for the constraints, they support many operations as well as the functions. 
\begin{figure}[htbp]
\centering
\begin{subfigure}[b]{.48\textwidth}
\centering
\includegraphics[width=\textwidth]{figs/minizincexample1.png}
\caption{Minizinc code example1}
  \label{fig:minizincexample1}
\end{subfigure}
\begin{subfigure}[b]{.48\textwidth}
\centering
\includegraphics[width=\textwidth]{figs/minizincexample2.png}
\caption{Minizinc code example2}
  \label{fig:minizincexample2}
\end{subfigure}
\caption{Minizinc examples}
  \label{fig:minizincexamples}
\end{figure}

   

  


