\chapter{Evaluation}
\label{cha:evaluation}
\section{Experiment Environment}
\subsection{Software Platform}
\label{sec:softplat}
\section{Minizinc IDE}
MiniZinc is a constraint modeling language, which is developed by the University of Melbourne, Monash University , and Data61 Decision Sciences\cite{r6}. The minizinc IDE provides a function that transfers the minizinc language to flatzinc language which can be understood by massive solvers\cite{r5}. Meanwhile, it provides some build-in functions as well as optimization methods. In general, the optimizations about minizinc are mainly divided into 2 aspects. One is to optimise the model itself, the other is based on the solvers. For the model itself, the highest level of optimization is arc consistency. Meanwhile, various solvers have different features.
\subsection{Solver}
As is shown in the figure 1, Flatzinc plays a role of bridge which connects the minizinc with different solvers and correspond interface. A wide range of solvers has supported flatzinc such as Choco, Chuffed, Coin-bc, picatSAT, Gurobi, Jacop, Or-tool, Yuck, Izplus and so on.
Choco: A JAVA CSP solver, which supports many search strategies( DomWDeg, ABS, IBS, first-fail, etc.) and optimization processes( LNS, fast restart).\\
chuffed: A C++ FD solver using lazy clause generation, which contains a nogood logbook to avoid plenty of duplicate calculation.\\
Coin-bc: A C++ based Mixed Integer Programming (here the MIP model is the same with CSP model) solver, it adopts the branch and cut optimization.\\
picatSAT: A CSP solver based on picat which is a rule-based language. And it adopts log encoding\cite{r8}.\\
Gurobi: A commerical solver support MIP.\\
Jacop: A JAVA CSP solver.\\
Or-tool: An open-source solver developed by google, it combines many optimization methods.\\
Yuck: Based on scala and combines local search with restarting, global constraints, and lexicographic cost functions.\\
Izplus: Based on iZ-C constraint programming that is developed by NTT DATA SEKISUI SYSTEMS CORPORATION. It combines Randomized restarting, Local search, Variable reordering and NG learning.

You can also use inline code, like \icode{a && b}. Notice how, unlike when
using the \texttt{texttt} command, the \icode{icode} macro also scales the
x-height of the monospace font correctly.

\subsection{Hardware Platform}
\label{sec:hardplat}

Table~\ref{tab:machines} shows how to include tables and
Figure~\ref{fig:helloworld} shows how to include codes. Notice how we
can also use the \textsf{cleveref} package to insert references like
\cref{tab:machines}, by writing just \textbackslash
cref\{tab:machines\}.

We can also refer to specific lines of code in code listings. The bug
in \Cref{fig:c:hello} is on \cref{line:bug}. There is also a bug in
\Cref{fig:java:hello} on
\crefrange{line:jbug-start}{line:jbug-end}. To achieve these
references we put \texttt{(*@ \textbackslash label\{line:bug\} @*)} in
the code -- the \texttt{(*@ @*)} are escape delimiters that allow you
to add LaTeX in the (otherwise verbatim) code file.

\begin{table*}
  \centering

  \caption{Processors used in our evaluation.  Note that the caption
    for a table is at the top.  Also note that a really long comment
    that wraps over the line ends up left-justified.}
  
  \label{tab:machines}
  \input table/machines.tex
\end{table*}

\begin{figure}
  \centering
  \begin{subfigure}[b]{\textwidth}
      \lstinputlisting[linewidth=\textwidth,breaklines=true]{code/hello.c}
      \caption{C}
      \label{fig:c:hello}
  \end{subfigure}

  \begin{subfigure}[b]{\textwidth}
      \lstinputlisting[linewidth=\textwidth,breaklines=true]{code/hello.java}
      \caption{Java}
      \label{fig:java:hello}
  \end{subfigure}

  \caption{Hello world in Java and C. This short caption is centered.}
  \label{fig:helloworld}
\end{figure}
\section{Result}
\label{sec:Result}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "paper"
%%% End: 
